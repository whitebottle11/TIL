# 20240112
## git 사용법
- git init - 초기화, 처음에만 하면 됨(저장소 안에 저장소를 넣으면 안됨 주의)
- git add [파일 이름]
- git commit -m "이름"
- git status - 현재상태 확인 빨강 - 워킹 디렉토리, 초록 - 스테이징
- git log - commit 목록보기(한줄은 --oneline 추가)

## git 저장소 추가
- git remote add origin [주소](물결있으면 지우기)
- git push origin(저장소 이름) master(가지)
- git pull origin master - push랑 동작 같음
- git clone [https: 주소 ] - clone으로 받은 프로젝트는 이미 git init이 되어잇음, git remote add 안해도됨, 저장소가 아닌곳에서 clone 받아야함
- git remote -v(저장소 목록)

## git 사용자 바꾸기
- git config --global user.email "name@naver.com"
- git config --unset user.email
- git config —global -l (list) - git global 설정 정보 보기
- 윈도우 검색 - 자격증명


## gitignore
- gitignore(특정 파일이나 디렉토리 추적x - 텍스트 파일임)(파일명앞에 . 확장자 없음) - gitigonore.io(싸이트)

## 추가로 알게된것
- 저장소가 다르면 이름이 같아도 상관없다(origin) - 저장소 주소가 중요
-----
# 20240115
## 프로그램

- 명령어들의 집합
- 새 연산을 정의하고 조합하여 유용한 작업을 수행하는 것
- **문제를 해결하는 매우 강력한 방법**

---

## 프로그래밍 언어

- 컴퓨터에게 작업을 지시하고 문제를 해결하는 도구

---

## 파이썬을 사용하는 이유

- 간결하고 읽기 쉬운 문법
- 다양한 응용분야(데이터 분석, 인공지능, 웹개발)
- 세계적인 규모의 커뮤니티, 포럼

---

## 파이썬 프로그램이 실행되는 법

인터프리터가 사용자의 명령어를 운영체제가 이해하는 언어로 바꿈

인터프리터를 사용하는 방법

1. shell 이라는 프로그램으로 한번에 한 명령어 씩 입력해서 실행
2. 확장자각 .py인 파일에 작성된 파이썬 프로그램을 실행 

---

## 표현식과 값

- 표현식 - 값, 변수, 연산자 등을 조합하여 계산되고 결과를 내는 코드 구조(표현식이 평과
- 평가
    - 표현식이나 문장을 순차적으로 평가하여 프로그램의 동작을 결정
    - 문장 - 실행 가능한 동작을 기술하는 코드(조건문 반복문 함수)
    

---

## 타입

값이 어떤 종류의 데이터인지, 어떻게 해석되고 처리되어야 하는지를 정의

타입은 2가지 요소로 이루어짐

- 값
- 값에 적용할 수 있는 연산

 

---

## 연산자

-2 ** 4의 경우 -16이 나옴(**이 우선순위가 높아서)

→ (-2) ** 4 가 되어야 16이 나옴

---

## 변수

값을 **참조**하는 이름

메모리에 저장됨 - 변수는 그 변수가 참조하는 객체의 **메모리 주소**를 가짐(참조)

객체 - 타입을 갖는 메모리 주소 내 값(값이 들어있는 상자)

기존에 존재했던 변수에 재사용시 **메모리 주소를 변경**

---

## 스타일 가이드

프로그래밍의 맞춤법

---

## 주석

ctrl + / (한번에 주석달고 풀 수 있는 단축키)

---

## 진수표현

- 2진수(binary) :  0b
- 8진수(octal) :  0o
- 16진수(hexadecimal) : 0x

---

# 유한 정밀도

콤퓨터 메모리 용량이 한정돼 있고 한 숫자에 대해 저장하는 용량이 제한 됨 - 실제 값이 아닌 가장 가까운 근사값을 저장

floating point rounding error 해결책

- 두 수의 차이가 매우 작은 수보다 작은지 확인 - abs(a-b) ≤ 1e - 10
- math 모듈 활용 - math.isclose(a,b)

---

# 지수 표현 방식

314 * 0.01 = 314e-2

---

# sequence Type

- 값들이 순서대로 저장( **정렬이 되어있는것은 아님**)
    - sequence Type은 정렬되어 있다 → (X)

## 문자열 표현

작은따옴표’ 또는 큰따옴표”로 감싸서 표현 - 둘 중 하나로 통일해주어야 함

따옴표 안에 따옴표를 표현할 경우 다른 따옴표를 사용하여 표현

## f-string

문자열에 f 또는 F 접두어를 붙이면 {}안에 변수나 표현식을 삽입 가능

**{변수}[ : ]가 가능함** 

ex) little = ‘작은별’    

print(f’{little[:2]} {little[-1]}) → 작은 별

{변수:.2f} → 소수점 2자리까지 나타내라

{변수*변수*변수} 가능

{변수*변수*변수:.2f} → 변수의 곱의 결과값의 소수 2자리까지 나타내라

## slicing

step을 지정하여 추출 - my_str[0 : 5 : 2] → 한칸씩 건너뛰며 추출(0,2,4)

문자열 뒤집기 - my_str[ : : -1]

## 문자열은 불변

**문자열 일부를 바꿀수는 없다 - 메모리에 덩어리채로 들어가기 때문**

바꾸고 싶다면 새로운 문자열을 만들어야 함(메모리 유지 못함)

---

# 추가로 알게된 것

## f-string

문자열에 f 또는 F 접두어를 붙이면 {}안에 변수나 표현식을 삽입 가능

**{변수}[ : ]가 가능함** 

ex) little = ‘작은별’    

print(f’{little[:2]} {little[-1]}) → 작은 별

{변수:.2f} → 소수점 2자리까지 반올림하여 나타내라

f'{name:10} -> 최소 문자열 폭을 10자리까지 나타내라(문자열 정렬할 때 유용함)

{변수*변수*변수} 가능

{변수*변수*변수:.2f} → 변수의 곱의 결과값의 소수 2자리까지 나타내라

## slicing

step을 지정하여 추출 - my_str[0 : 5 : 2] → 한칸씩 건너뛰며 추출(0,2,4)
변수명[0:5:-1] → 실행안됨 ⇒ 반대로 출력하고 싶다면 변수명[ : : -1]

## string

따옴표는 쓰는 순서 관계없이 적용됨

따옴표 안에 큰따옴표를 넣고 싶다면 작은 따옴표 안에 큰 따옴표를 쓰거나 \”를 사용

## 문자열 format 매서드
print('{0}와{1}은 같지 않다'.format('사과','당근')) ==> 사과와 당근은 같지 않다
print('{1}와{0}은 같지 않다'.format('사과','당근')) ==> 당근와 사과은 같지 않다
print('We are the {} who say "{}!"'.format('knights', 'Ni')) ==> We are the knights who say "Ni!"
print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg')) ==> The story of Bill, Manfred, and Georg.
---
# 2024-01-16

---

## sequence Types

여러 개의 값들을 순서대로 나열하여 저장하는 자료형(str, list, tuple, range) → **정렬 X**

### tuple(튜플)

여러 개의 값을 **순서대로 저장**하는 **변경 불가능**한 시퀸스 자료형

어떤 자료형도 저장 가능

```python
my_tuple_1 = ()

my_tuple_2 = (1**,**) → 콤마를 반드시 넣어줘야 함(빠지면 정수 1이 되어버림)

my_tuple_3 = (1, ‘a’, 3, ‘b’)
```

개발자가 의도적으로 쓰기보다 파이썬 내부 동작에서 쓰임

파이썬은 ,를 통해 한번에 할당 가능 → x,y = (10,20)

→ x = 10, y = 20 (괄호는 생략 가능하다)

### range

연속된 정수 시퀀스를 **생성**하는 **변경 불가능**한 자료형

range(n) → 0부터 n-1까지 숫자 시퀸스

range(n,m) → n부터 m-1까지의 숫자 시퀸스

print(range(5)) == range(0,5)

→ 리스트로 형변환 시 데이터 확인 가능 =⇒ print(list(my_range_1)) #[0,1,2,3,4] 

---

## Non-sequence Type

### dict - 딕셔너리

**key - value** 쌍으로 이루어진 **순서와 중복이 없는 변경 가능**한 자료형

key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range…)

value는 모든 자료형 사용 가능

{}로 표시 my_dic = {’key’ : ‘value’, ‘list’ : [1,2,3]}

key로 접근(my_dict[’apple’]) - 순서가 없기때문에 인덱스로 접근 못함

중복안됨 → 마지막에 넣은 값이 나옴

### set

**순서와 중복이 없는 변경 가능**한 자료형

{}로 표기

```python
my_set_1 = set()

my_set_2 = {1, 2, 3} 

my_ set_3 = {1, 1, 1} == {1}
```

set는 **집합연산**이 가능함 - 합집합, 차집합, 교집합

---

## Other types

### None

값이 없음을 표현하는 자료형

print 가능

N이 대문자임

### Boolean

참과 거짓을 표현하는 자료형 (T와 F를 대문자로 써야함)

collection

---

## Type Conversion

### 암시적 형변환

파이썬이 자동으로 형변환 하는 것

```python
print(3+0.5) = 8.0

print(True + 3) = 4       True는 1 False는 0 거의 다 적용됨

print(True + False) = 1
```

### 명시적 형변환

개발자가 직접 형변환 하는 것(암시적 형변환이 아닌 모든 경우)

str → integer : 형식에 맞는 숫자만 가능

integer → str : 모두 가능

---

## 비교 연산자

### is 비교 연산자

메모리 내에서 같은 객체를 참조하는지 확인(주소를 비교)

==은 동등성(equality), is 는 식별성(identitiy)

```python
print(1==True) → True (암시적 형변환 일어남)

print(1 is True) → False
```

---

## 논리 연산자

### 단축평가

논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

```python
vowels = ’aeiou’

print((’a’ and ‘b’) in vowels) == b in vowels

print((’b’ and ‘a’) in vowels) == a in vowels

print(3 and 5) = 5

print(0 and 3) = 0 → 단축평가

print(5 or 3) = 5 → 단축평가

print(3 or 0) = 3 → 단축평가

print(0 or 3) = 3
```

---

## 추가로 알게 된 것

### mutable

값이 변한다

### immutable

값이 변하지 않는다

### 얕은 복사(shallow copy)

b에 a를 할당하면 값이 할당되는 것이 아니라 같은 메모리 주소를 바라본다

따라서 b를 변경하면 a도 바뀐다

```python
a = [1, 2, 3]
>>> b = a # shallow copy
>>> b[0]= 5
>>> a
[5, 2, 3]
>>> b
[5, 2, 3]
>>> id(a)
4396179528
>>> id(b)
4396179528
```

### 깊은 복사(deep copy)

내부의 객체들까지 모두 새롭게 copy되는 것

```python
import copy
>>> a = [[1,2],[3,4]]
>>> b = copy.deepcopy(a)
>>> a[1].append(5)
>>> a
[[1, 2], [3, 4, 5]]
>>> b
[[1, 2], [3, 4]]
```

a를 변경해도 b가 바뀌지 않는다