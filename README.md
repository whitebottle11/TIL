# 20240112
## git 사용법
- git init - 초기화, 처음에만 하면 됨(저장소 안에 저장소를 넣으면 안됨 주의)
- git add [파일 이름]
- git commit -m "이름"
- git status - 현재상태 확인 빨강 - 워킹 디렉토리, 초록 - 스테이징
- git log - commit 목록보기(한줄은 --oneline 추가)

## git 저장소 추가
- git remote add origin [주소](물결있으면 지우기)
- git push origin(저장소 이름) master(가지)
- git pull origin master - push랑 동작 같음
- git clone [https: 주소 ] - clone으로 받은 프로젝트는 이미 git init이 되어잇음, git remote add 안해도됨, 저장소가 아닌곳에서 clone 받아야함
- git remote -v(저장소 목록)

## git 사용자 바꾸기
- git config --global user.email "name@naver.com"
- git config --unset user.email
- git config —global -l (list) - git global 설정 정보 보기
- 윈도우 검색 - 자격증명


## gitignore
- gitignore(특정 파일이나 디렉토리 추적x - 텍스트 파일임)(파일명앞에 . 확장자 없음) - gitigonore.io(싸이트)

## 추가로 알게된것
- 저장소가 다르면 이름이 같아도 상관없다(origin) - 저장소 주소가 중요
-----
# 20240115
## 프로그램

- 명령어들의 집합
- 새 연산을 정의하고 조합하여 유용한 작업을 수행하는 것
- **문제를 해결하는 매우 강력한 방법**

---

## 프로그래밍 언어

- 컴퓨터에게 작업을 지시하고 문제를 해결하는 도구

---

## 파이썬을 사용하는 이유

- 간결하고 읽기 쉬운 문법
- 다양한 응용분야(데이터 분석, 인공지능, 웹개발)
- 세계적인 규모의 커뮤니티, 포럼

---

## 파이썬 프로그램이 실행되는 법

인터프리터가 사용자의 명령어를 운영체제가 이해하는 언어로 바꿈

인터프리터를 사용하는 방법

1. shell 이라는 프로그램으로 한번에 한 명령어 씩 입력해서 실행
2. 확장자각 .py인 파일에 작성된 파이썬 프로그램을 실행 

---

## 표현식과 값

- 표현식 - 값, 변수, 연산자 등을 조합하여 계산되고 결과를 내는 코드 구조(표현식이 평과
- 평가
    - 표현식이나 문장을 순차적으로 평가하여 프로그램의 동작을 결정
    - 문장 - 실행 가능한 동작을 기술하는 코드(조건문 반복문 함수)
    

---

## 타입

값이 어떤 종류의 데이터인지, 어떻게 해석되고 처리되어야 하는지를 정의

타입은 2가지 요소로 이루어짐

- 값
- 값에 적용할 수 있는 연산

 

---

## 연산자

-2 ** 4의 경우 -16이 나옴(**이 우선순위가 높아서)

→ (-2) ** 4 가 되어야 16이 나옴

---

## 변수

값을 **참조**하는 이름

메모리에 저장됨 - 변수는 그 변수가 참조하는 객체의 **메모리 주소**를 가짐(참조)

객체 - 타입을 갖는 메모리 주소 내 값(값이 들어있는 상자)

기존에 존재했던 변수에 재사용시 **메모리 주소를 변경**

---

## 스타일 가이드

프로그래밍의 맞춤법

---

## 주석

ctrl + / (한번에 주석달고 풀 수 있는 단축키)

---

## 진수표현

- 2진수(binary) :  0b
- 8진수(octal) :  0o
- 16진수(hexadecimal) : 0x

---

# 유한 정밀도

콤퓨터 메모리 용량이 한정돼 있고 한 숫자에 대해 저장하는 용량이 제한 됨 - 실제 값이 아닌 가장 가까운 근사값을 저장

floating point rounding error 해결책

- 두 수의 차이가 매우 작은 수보다 작은지 확인 - abs(a-b) ≤ 1e - 10
- math 모듈 활용 - math.isclose(a,b)

---

# 지수 표현 방식

314 * 0.01 = 314e-2

---

# sequence Type

- 값들이 순서대로 저장( **정렬이 되어있는것은 아님**)
    - sequence Type은 정렬되어 있다 → (X)

## 문자열 표현

작은따옴표’ 또는 큰따옴표”로 감싸서 표현 - 둘 중 하나로 통일해주어야 함

따옴표 안에 따옴표를 표현할 경우 다른 따옴표를 사용하여 표현

## f-string

문자열에 f 또는 F 접두어를 붙이면 {}안에 변수나 표현식을 삽입 가능

**{변수}[ : ]가 가능함** 

ex) little = ‘작은별’    

print(f’{little[:2]} {little[-1]}) → 작은 별

{변수:.2f} → 소수점 2자리까지 나타내라

{변수*변수*변수} 가능

{변수*변수*변수:.2f} → 변수의 곱의 결과값의 소수 2자리까지 나타내라

## slicing

step을 지정하여 추출 - my_str[0 : 5 : 2] → 한칸씩 건너뛰며 추출(0,2,4)

문자열 뒤집기 - my_str[ : : -1]

## 문자열은 불변

**문자열 일부를 바꿀수는 없다 - 메모리에 덩어리채로 들어가기 때문**

바꾸고 싶다면 새로운 문자열을 만들어야 함(메모리 유지 못함)

---

# 추가로 알게된 것

## f-string

문자열에 f 또는 F 접두어를 붙이면 {}안에 변수나 표현식을 삽입 가능

**{변수}[ : ]가 가능함** 

ex) little = ‘작은별’    

print(f’{little[:2]} {little[-1]}) → 작은 별

{변수:.2f} → 소수점 2자리까지 반올림하여 나타내라

f'{name:10} -> 최소 문자열 폭을 10자리까지 나타내라(문자열 정렬할 때 유용함)

{변수*변수*변수} 가능

{변수*변수*변수:.2f} → 변수의 곱의 결과값의 소수 2자리까지 나타내라

## slicing

step을 지정하여 추출 - my_str[0 : 5 : 2] → 한칸씩 건너뛰며 추출(0,2,4)
변수명[0:5:-1] → 실행안됨 ⇒ 반대로 출력하고 싶다면 변수명[ : : -1]

## string

따옴표는 쓰는 순서 관계없이 적용됨

따옴표 안에 큰따옴표를 넣고 싶다면 작은 따옴표 안에 큰 따옴표를 쓰거나 \”를 사용

## 문자열 format 매서드
print('{0}와{1}은 같지 않다'.format('사과','당근')) ==> 사과와 당근은 같지 않다
print('{1}와{0}은 같지 않다'.format('사과','당근')) ==> 당근와 사과은 같지 않다
print('We are the {} who say "{}!"'.format('knights', 'Ni')) ==> We are the knights who say "Ni!"
print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg')) ==> The story of Bill, Manfred, and Georg.
---
# 2024-01-16

---

## sequence Types

여러 개의 값들을 순서대로 나열하여 저장하는 자료형(str, list, tuple, range) → **정렬 X**

### tuple(튜플)

여러 개의 값을 **순서대로 저장**하는 **변경 불가능**한 시퀸스 자료형

어떤 자료형도 저장 가능

```python
my_tuple_1 = ()

my_tuple_2 = (1**,**) → 콤마를 반드시 넣어줘야 함(빠지면 정수 1이 되어버림)

my_tuple_3 = (1, ‘a’, 3, ‘b’)
```

개발자가 의도적으로 쓰기보다 파이썬 내부 동작에서 쓰임

파이썬은 ,를 통해 한번에 할당 가능 → x,y = (10,20)

→ x = 10, y = 20 (괄호는 생략 가능하다)

### range

연속된 정수 시퀀스를 **생성**하는 **변경 불가능**한 자료형

range(n) → 0부터 n-1까지 숫자 시퀸스

range(n,m) → n부터 m-1까지의 숫자 시퀸스

print(range(5)) == range(0,5)

→ 리스트로 형변환 시 데이터 확인 가능 =⇒ print(list(my_range_1)) #[0,1,2,3,4] 

---

## Non-sequence Type

### dict - 딕셔너리

**key - value** 쌍으로 이루어진 **순서와 중복이 없는 변경 가능**한 자료형

key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range…)

value는 모든 자료형 사용 가능

{}로 표시 my_dic = {’key’ : ‘value’, ‘list’ : [1,2,3]}

key로 접근(my_dict[’apple’]) - 순서가 없기때문에 인덱스로 접근 못함

중복안됨 → 마지막에 넣은 값이 나옴

### set

**순서와 중복이 없는 변경 가능**한 자료형

{}로 표기

```python
my_set_1 = set()

my_set_2 = {1, 2, 3} 

my_ set_3 = {1, 1, 1} == {1}
```

set는 **집합연산**이 가능함 - 합집합, 차집합, 교집합

---

## Other types

### None

값이 없음을 표현하는 자료형

print 가능

N이 대문자임

### Boolean

참과 거짓을 표현하는 자료형 (T와 F를 대문자로 써야함)

collection

---

## Type Conversion

### 암시적 형변환

파이썬이 자동으로 형변환 하는 것

```python
print(3+0.5) = 8.0

print(True + 3) = 4       True는 1 False는 0 거의 다 적용됨

print(True + False) = 1
```

### 명시적 형변환

개발자가 직접 형변환 하는 것(암시적 형변환이 아닌 모든 경우)

str → integer : 형식에 맞는 숫자만 가능

integer → str : 모두 가능

---

## 비교 연산자

### is 비교 연산자

메모리 내에서 같은 객체를 참조하는지 확인(주소를 비교)

==은 동등성(equality), is 는 식별성(identitiy)

```python
print(1==True) → True (암시적 형변환 일어남)

print(1 is True) → False
```

---

## 논리 연산자

### 단축평가

논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

```python
vowels = ’aeiou’

print((’a’ and ‘b’) in vowels) == b in vowels

print((’b’ and ‘a’) in vowels) == a in vowels

print(3 and 5) = 5

print(0 and 3) = 0 → 단축평가

print(5 or 3) = 5 → 단축평가

print(3 or 0) = 3 → 단축평가

print(0 or 3) = 3
```

---

## 추가로 알게 된 것

### mutable

값이 변한다

### immutable

값이 변하지 않는다

### 얕은 복사(shallow copy)

b에 a를 할당하면 값이 할당되는 것이 아니라 같은 메모리 주소를 바라본다

따라서 b를 변경하면 a도 바뀐다

```python
a = [1, 2, 3]
>>> b = a # shallow copy
>>> b[0]= 5
>>> a
[5, 2, 3]
>>> b
[5, 2, 3]
>>> id(a)
4396179528
>>> id(b)
4396179528
```

### 깊은 복사(deep copy)

내부의 객체들까지 모두 새롭게 copy되는 것

```python
import copy
>>> a = [[1,2],[3,4]]
>>> b = copy.deepcopy(a)
>>> a[1].append(5)
>>> a
[[1, 2], [3, 4, 5]]
>>> b
[[1, 2], [3, 4]]
```

a를 변경해도 b가 바뀌지 않는다


# 20240117

# 함수
&emsp; 특정 작업을 수행하기 위한 **재사용 가능**한 코드 묶음

## 내장함수
- 파이썬이 기본적으로 제공하는 함수
별도의 **import없이** 바로 사용 가능
```
result = abs(-1)
```

## 함수 구조
- parameter : 매개변수
- body
- return value : 반환값

## 함수의 정의와 호출
- Docstring
    ```
    """
    함수의 설명법
    """
    ```로 함수의 사용법을 적음
- return
    함수의 실행을 종료하고 결과를 호출 부분으로 반환

## 매개변수와 인자
### 매개변수(parameter)
&emsp; 함수를 **정의**할 때 함수가 받을 값을 나타내는 변수
### 인자(argument)
&emsp; 함수를 **호출**할 때, 실제로 전달되는 값

1. Positional Arguments(위치인자)  
   - 함수 호출시 인자의 위치에 따라 전달되는 인자  
   - **위치인자는 함수 호출 시 반드시 값을 전달해야 함**
2. Default Argument Value(기본 인자 값)
   - 함수 정의에서 매개변수에 기본 값을 할당하는 것
   - 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당됨
3. Keyword Argument(키워드 인자)
   - 함수 호출시 인자의 이름과 함께 값을 전달하는 인자
   - **호출 시 키워드 인자는 위치 인자 뒤에 위치해야 함**(인자가 어느 위치인지 알 수 없기 때문)
4. Arbitrary Argument Lists(임의의 인자 목록)
   - 정해지지 않은 개수의 인자를 처리하는 인자
   - 함수 정의 시 매개변수 앞에 '*'를 붙여 사용하며, 여러개의 인자를 tuple로 처리
5. Arbitrary Keyword Argument Lists(임의의 키워드 인자 목록)
   - 정해지지 않은 개수의 키워드 인자를 처리하는 인자
   - 함수 정의 시 매개변수 앞에 '**'를 붙여 사용
   - 여러 개의 인자를 dictionary로 묶어 처리

### 함수 인자 권장 작성순서  
&emsp; 위치 -> 기본 -> 가변 -> 가변키워드
```
def func(pos1, pos2, age =30, *args, **kargs):
print(pos1, pos2, age, args, kargs)
func(10, 10, 50, (10,30), {})
-> 10 10 50 10 30 {}
```
## 파이썬의 범위(Scope)
- 로컬 변수를 글로벌에서 사용할 수 없음
- 이는 변수의 **수명주기**와 연관있음

### 이름 검색 규칙(Name Resolution)
- LEGB Rule
- **함수 내에서는 바깥 Scope의 변수에 접근 가능하나 수정은 할 수 없음**
- 반대로(안쪽으로) 찾아가는것은 불가

## 유용한 내장함수
### map(function, iterable)
- 순회 가능한 데이터구조(iterable)의 모든 요소에 함수를 적용하고, 그 결과를 map object로 반환
- map 함수로 쓴 데이터는 mpa object 덩어리기 때문에 list로 감싸주어야 함
- map에 함수 매개변수를 줄 때 ()을 빼고 함수명만 넣어야 함("()"을 넣으면 map이 실행될때 매개변수로 넣은 함수가 같이 실행되기 때문)

### zip(*iterables)
- 임의의 iterable을 모아 튜플을 원소로 하는 zip object를 반환

### lambda(람다)함수
- 이름 없이 정의되고 사용되는 익명 함수
- lambda 매개변수 : 표현식
- map의 첫번째 인자에 많이 쓰임
```
numbers = [1, 2, 3, 4, 5]
def func(x):
    return x ** 2

result = list(map(func, numbers))
pritn(result)

result2 = list(map(lambda x: x**2, numbers))
print(result2)
```
## Packing & Unpacking
### Packing
- 여러개의 값을 하나의 변수에 묶어서 담는 것
- 변수에 담긴 값들은 튜플(tuple)형태로 묶임

### unpacking
- 패킹된 변수의 값을 개별적인 변수로 분리하여 할당하는 것
- *는 리스트 요소를 언패킹
- **는 딕셔너리의 키-값 쌍을 함수의 키워드 인자로 언패킹(인자와 매개변수가 같아야 함)
---
# 추가로 알게된 것
1. 파이썬에서는 return이 없는 함수는 자동을 none을 리턴
   ```
   a = print(1)
   print(a) # None
   ```
2. global 글로벌변수 의 값을 변경할 경우 재할당을 해야하기 때문에 global 변수명을 적어야 한다 - print()는 변수명을 안 적어도 가능(참조는 가능, 재할당은 불가능)
3. 함수의 매개변수로 Unpacking을 줄 경우 튜플로 만들어져서 나온다
   ```
   def create_user(*total_user_info):
    print(total_user_info)
    name, age, address = total_user_info
    increase_user()
    user_info = {'name': name, 'age' : age, "address" : address}
    print(f'{user_info["name"]}님 환영합니다!')
    return user_info



    name = ['김시습', '허균', '남영로', '임제', '박지원']
    age = [20, 16, 52, 36, 60]
    address = ['서울', '강릉', '조선', '나주', '한성부']
    total_user_info = list(zip(name, age, address)) 
    print(list(map(create_user, total_user_info)))
   ```
   결과 : ValueError: not enough values to unpack (expected 3, got 1)
   이유 : (('김시습', 20, '서울'),)

    ### 올바른 코드
   ```
   def create_user(*total_user_info):
    name, age, address = total_user_info
    increase_user()
    user_info = {'name': name, 'age' : age, "address" : address}
    print(f'{user_info["name"]}님 환영합니다!')
    return user_info



    name = ['김시습', '허균', '남영로', '임제', '박지원']
    age = [20, 16, 52, 36, 60]
    address = ['서울', '강릉', '조선', '나주', '한성부']
    print(list(map(create_user, name, age, address)))
   ```
   결과 :('김시습', 20, '서울')로 매개변수가 들어감
   
4. map의 인자는 여러개 들어갈 수 있다 - map(함수, args1, args2, ...)
5. lambda 함수에 딕셔너리가 바로 들어갈 수 있다
    ```
   list(map(lambda user_info: {'name' : user_info['name']}, iterable))
   ```
6. 함수의 바디가 존재하면 lambda함수로 만들 수 없다.
7. map의 인자로 리스트를 줄 경우 리스트가 벗겨져서 들어간다 - [{'ㅁ' : 1, 'ㄴ' : 2}] -> {'ㅁ' : 1, 'ㄴ' : 2} ( 안의 요소들만 들어가기 때문)

# 2024-01-18
## 모듈
- 한 파일로 묶인 변수와 함수의 모음 -> .py 파일
- .(dot)는 왼쪽의 객체에서 오른쪽 이름을 찾아라 라는 의미의 연산자
- 만약 서로 다른 모듈이 같은 이름의 함수를 제공할 경우 문제 발생 -> 마지막에 import된 이름으로 대체됨

## 파이썬 표준 라이브러리(PSL)
파이썬 언어와 한께 제공되는 다양한 모듈과 패키지의 모음

## pip
- 외부 패키지들을 설치하도록 도와주는 파이썬의 패키지 관리 시스템

## List comprehension 구조
- 간결하고 효율적인 리스트 생성 방법
- [expression for 변수 in iterable]
- [expression for 변수 in iterable if 조건식]
  
## enumerate(iterable, start = 0)
- iterable 객체의 각 요소에 대해 인덱스와 함께 반환하는 내장함수

## 추가로 알게 된 것
- 함수 return의 데이터 타입은 다르게 리턴할 수 있다(리턴될 때 데이터 타입 결정)
```
def func():
   return "ex"
   return a,b  #튜플로 출력 됨
``` 
- 딕셔너리의 출력 순서는 만들어질 때 정해짐

# 20240122
## 메서드
 - 메서드는 클래스 내부에 정의되는 함수
 - 클래스는 파이썬에서 '타입을 표현하는 방법이며 은연중에 사용해왔음
 - 객체.메서드
 ### 문자열 조작 메서드
- 바꿀 수 없기 때문에 새로운 문자열을 리턴한다
- .replace(old, new[, count]) - []는 선택인자라는 뜻(안넣어도 됨)
- 언어가 다르더라도 공통적으로 표기(베커스 나우르 표기법)
- .split(sep = None, maxsplit = -1) 아무것도 안넣을 시 공백이 기준
- 앞의 결과가 None이라면 이어서 활용 불가
- print(my_list.append([10,9,,8])) - None이 출력, 원본을 바꾸는 함수는 반환값이 없다
- .pop(i) i 값을 안주면 마지막요소 삭제
- .sort() 반환값 None -> 원본을 바꾼다, sort(reverse = False)가 기본 (reverse = True)로 바꿀 시 내림차순 가능
### 복사
- 변경가능한 데이터 타입의 복사와 변경 불가능한 데이터 타입의 복사는 다르다
- 리스트 복사 : 할당 연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사한다
- 얕은 복사의 한계 : 2차원 리스트 까지는 복사를 못한다(원본과 같은 주소를 가짐)
## 추가로 알게 된 것
- min(리스트), max(리스트)는 내장함수로 최솟값과 최댓값을 구해준다.
- revered(리스트)를 사용하면 object 형태로 반환되기 때문에 join()이나 list()를 사용하여 문자나 리스트 형태로 바꿔주어야 한다.
- sort()를 사용하면 반환값이 없다 (원본을 바꾸기 때문에 return 값이 필요없다) 따라서 결과를 다른 변수에 할당하지 못한다(reserved()를 대신 사용)
- 빈배열.extend(arr)을 하면 arr의 각 문자열이나 원소를 모두 나누어 빈 배열에 담는 것이 가능하다
  ```
  original_word = '코딩 공부는ㄴ 1일ㄹ 1커ㅓ밋ㅅ @@@#^()#_+!&~:"'

  arr = []
   arr.extend(original_word)
   print(arr)
   # ['코', '딩', ' ', '공', '부', '는', 'ㄴ', ' ', '1', '일', 'ㄹ', ' ', '1', '커', 'ㅓ', '밋', 'ㅅ', ' ', '@', '@', '@', '#', '^', '(', ')', '#', '_', '+', '!', '&', '~', ':', '"']
   ```
- int 타입을 extend()를 사용하여 배열의 넣을 경우 []로 감싸 리스트로 만들어 주면 된다.
- .split('구분자')를 사용하면 구분자는 문자열에 포함되지 않는다
  ```
  text = 'hello world ioioi'
   a = text.split('o')
   print(a)
   # ['hell', ' w', 'rld i', 'i', 'i']
  ```
- 파이썬의 변수는 타입을 명시하지 않아 자유롭게 바꿀 수 있다
   ```
   a = [1,2,3]
   b = a
   a = 50
   print(a,b)
   # 50 [1, 2, 3]
   ```

# 20240123
## 비시퀸스 데이터 구조
### set
- .remove(x) x가 없다면 에러 but .discard(x)는 없어도 에러없음
### 딕셔너리 관련 키원드
- .keys()를 사용하면 []형태로 나옴
- .update(key=value)형태로도 사용가능, 인자 여러개 넣어도 가능하다
### 해시
- 순서가 상관이 없다
- set pop메서드: 정수 값 자체가 곧 해시 값이기 때문에 결과가 항상 같다, 문자는 항상 다름
- 정수는 해시 값이 정해져 있다(정수 값 == 해시 값) - 불피요한 연산을 줄일 수 있기 때문에
- 해시 테이블에 나열된 순서(색인)는 인덱스와 상관없다
- pop은 해시 테이블에서 먼저 있는 순서대로 값을 뺀다
- **정수는 해시 값이 고정되어 있을 뿐이지 순서가 있는 것은 아니다**
- "arbitrary" the docs don't mean "random"
- 배치된 순서대로 뽑아오지만 배치 순서는 임의로 정해진다
- tuple은 불변형이지만 list와 같이 해시 불가능한 객체를 참조 할 때는 tuple 자체도 해시 불가능해질 수 있다
- set안에 list 못들어감
## 추가로 알게 된 것
- set는 불변이기 때문에 가변적인 요소가 들어갈 수 없다.
- 정수와 문자를 섞었을 때 정수의 반환값도 바뀌는 이유: 해시값을 변수에 넣어진 순서대로 받기 때문에 같은 주소를 가질 수 없어 정수가 다른 주소를 가질 수 있다.
   ```
   my_str_set = {'a','b','c','d','e','f',3,2,1,9,100,4,87,39,10,52}
   print(my_str_set.pop())
   print(my_str_set.pop())
   print(my_str_set.pop())
   # 값이 매번 달라짐
   ```
- 정수의 해시값이 정수와 같은데 숫자의 순서대로 안나오는 이유: 해시 테이블은 정수 순서대로 정렬되어 있지 않기 떄문이다

# 20240124
## OPP
- 파이썬의 모든 것은 객체다
- 변수는 속성 메서드는 행동을 의미
  
### 클래스
- 클래스는 파이썬에서 타입을 표현하는 방법이다
- 객체 : 클래스에서 정의한 것을 토대로 메모리에 할당된 것, **속성**과 **행동**으로 구성된 모든 것
- 인스턴스: 클래스로 만든 객체
- 인스턴스의 역할 : 클래스가 가지고있는 메서드들을 쓸 수 있다
- 인스턴스 메서드 : 각각의 인스턴스에서 호출할 수 있는 메서드
- 속성 : 클래스 안의 변수
- 메서드 : 클래스 안의 함수
- 클래스는 파스칼케이스를 이용하여 이름을 작성함(_대신 대문자)
  
### 인스터스 매서드 
- **인스터스 메서드는 반드시 첫번째 매개변수로 인스터스 자신(self)을 전달받는다**
   ```
   'hello'.upper() == str.upper('hello')
   #'hello' 가 self로 들어가야함
   ```
- 인스턴스 메서드 첫번째 매개변수명은 self로 한단(바꿔도 오류가 생기지는 않지만 암묵적인 약속이다)

### 클래스 매서드
- @ :데코레이터
- **@classmethod** 데코레이터를 사용하여 정의
- 호출시, 첫번째 인자로 호출하는 클래스(cls)가 전달됨 
- 데코레이터가 있으면 클래스 메서드 없으면 인스턴스 메서드
- 클래스 메서드에 클래스명.변수가 아닌 cls.변수명을 쓰는 이유: 클래스를 상속받았을 경우 현재 클래스의 변수가 아닌 부모 클래스의 변수를 참조하게 된다.

### 스태틱 메서드
- **@staticmethod** 데코레이터를 사용하여 정의
- 호출시 필수적으로 작성해야 할 매개변수가 없음
- 클래스가 호출
- 클래스는 모든 메서드를 호출 할 수 있다. 하지만 클래스는 클래스 메서드와 스태틱 메서드만 사용하도록 한다.
   
### 매직메서드
- 특정 상황에 자동으로 호출되는 메서드
- __ str__(self): print할때 자동호출, print하는 문자열 변경가능
  
### 데코레이터
- 다른 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용되는 함수

### 추가로 알게 된 점
- 절차 지향과 객체 지향은 대조되는 개념이 아니다
- 인스턴스 메서드는 self.메서드명()을 통해 실행한다
- 인스턴스 메서드를 클래스 명을 이용하여 실행할 경우 매개변수에 self를 넣어주어야 한다
   ```
   Shape.calculate_area(self)
   ```
- 인스턴스 메서드 매개변수에 무조건 self 넣어줘야 한다
- 파일에서 데이터 받아오는 법
   ```
   movie = open('sample.json', encoding='utf-8')
   movie_detail = json.load(movie)
   # 파일이 현재 파일과 같은 파일에 있어야 함, 다른 파일에 있을 시 경로 추가
   ```

# 20240125
## OPP2
### 상속
- class 자식클래스(부모 클래스): 자식클래스가 부모클래스를 상속받는다
- 자식클래스에서 메서드 실행시 자식 클래스 내부에서 먼저 찾고 없다면 부모 클래서에서 찾아 실행한다.
- super() 쓰는 이유: 부모 클래스를 호출 -> 다중 상속 시 MRO를 기반으로 호출될 메서드를 결정하여 자동으로 호출(개발자가 직접 하나하나 하기 힘들다)
  1. 다중상속시 부모 구별
  2. 클래스명 변경시 일일히 찾을 필요 없음  
   ```
   class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email


   class Student(Person):
      def __init__(self, name, age, number, email, student_id):
        self.name = name
        self.age = age
        self.number = number
        self.email = email
        self.student_id = student_id


   class Student(Person):
      def __init__(self, name, age, number, email, student_id):
        super().__init__(self, name, age, number, email)
        self.student_id = student_id
   # super().__init__()을 사용하여 중복을 줄임
   # 매개변수는 꼭 넣어줘야 함
   ```
### 다중상속
- 중복된 메서드가 있는 경우 상속 순서에 의해 결정
- MRO : 메서드 결정 순서(깊이 우선, 왼쪽에서 오른쪽으로)
- 상속 받더라도 생성자 함수 안에 있는 변수는 찾지못한다
- D -> B -> C -> A 순으로 호출시 출력 순서는 A -> C -> B -> D => 스택형식

### 에러와 에시
- EOL : 라인이 끝나지 않음
- 예외는 built-in되어있음
### 예외 처리
- except에 적혀진 에러에만 반응, 아무것도  안적을시 모든 에러에 반응할 수 있지만 대응을 못하기 때문에 좋지 않음(else 처럼 사용 가능)
- BaseException : 모든 예외를 가지고 있는 최상위 클래스
- **내장 예외 클래스는 상속 계층구조를 가지기 때문에 반드시 하위 클래스를 먼저 확일 할 수 있도록 해야함**

### 새롭게 알 게 된것
- 클래스 함수의 cls는 함수를 호출하는 본인이다
   ```
   @classmethod
    def access_num_of_animal(cls):
        return f'동물의 수는 {cls.num_of_animal}마리 입니다.'
   ```
   - Cat.access_num_of_animal 과 cat.access_num_of_animal는 다르다 Cat.access_num_of_animal은 부모의 access_num_of_animal을 참조하고 cat.access_num_of_animal은 cat 인스턴스의 access_num_of_animal를 참조한다
- 함수명과 변수명이 같으면 오류가 생긴다
   ```
   def meow(self):
        print(self.meow) #ERROR
   ```
- 클래스 안에 있는 변수는 클래스의 속성이라고 부르며 생성자에서 받아온 변수는 인스턴스 변수라고 부른다
   ```
   class Cat:
      sound = '야옹'

      def __init__(self, name):
         self.name = name
   # sound는 클래스 속성, name은 인스턴스 변수
   ```
# 20240126
## 데이터 사이언스
### 파이썬 패키지
- numpy : 배열계산에 유용
- pandas : 정규분포 표준편차 계산 유용

# 20240129
- max, min을 못쓸 때 sort()나 sorted()로 정렬하는 방법이 있다.

# 20240130
## 정렬
### 카운팅 정렬
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다
   ```
   counts[:] <- counts[i-1] + counts[i]
   ```
- 뒤에서부터 하는 이유: 같은 값이 있을 때 순서가 바뀐다., (1,2), (1,3)과 같은 좌표일 시 문제가 발생한다
  ### baby-gin
  1. 완전 검색
     - 완전 검색 방법: 모든 경우의 수를 나열해보고 확인하는 기법
     - 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다
  2. 탐욕 알고리즘
      - 최적해를 구하는 데 사용되는 근시안적인 방법
      - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
      - c = [0]*12로 만드는 이유: run을 조사할때 뒤의 2개까지 조사해야 하기 때문에 c[i]가 9일 경우 c[10], c[11]이 있어야 함
## 추가로 알게된것
- 최댓값, 최솟값 비교할 때 math.inf, -math.inf 해주면 파이썬 상에서 가장 큰 값, 가장 작은 값이 들어간다.(import math 필요)
   ```
   import math
   max_val = math.inf
   min_val = -math.inf

   ```
- 문자를 입력받을떄 오류가 있는경우 .strip() 함수를 사용하면 해결될 수 있다(문제 출제자가 출제시 스페이스바 미스)

# 20240131
## 2차원 배열
- 2차원 배열 저장법
   ```
   N = int(input())
   arr = [list(map(int, input().split())) for _ in range(N)]
   arr2 = [[0]*N]*N   #안됨
   # 얕은 복사가 되서 arr[0][0]을 1로 바꿀시 arr[n][0]이 전부 1이 됨
   ```
### 비트 연산자
- i & (1 << j): i의 j번째 비트가 1인지 아닌지를 검사
- (1 << n) 이 부분집합의 갯수인 이유: 1 == 2의 0승이다 
- 공집합을 제거하려면 for i in range(1, 1 << n)을 하면 된다

### 추가로 알게된 것
- 부분집합 변수명 subset
- 2차배열 최대값 구할때 max(map(max)) 형태로 해야함

# 20240201
## 검색
### 순차 검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격이 증가하여 비효율적
- 정렬되지 않은 자료에서의 순차 검색의 평균 비교 횟수: (1/n)*(1+2+3+...+n) = (n+1)/2 => 시간 복잡도: O(n)
- 정렬된 자료에서 순차 검색의 평균은 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어든다 => 시간 복잡도 O(n)

### 이진 검색
- 자료가 정렬되어 있어야 함

### 인덱스 정렬
- 상대적으로 크기가 작은 인덱스 배열을 정렬하기 때문에 속도가 빠르다

### 선택 정렬
- 주어진 자료들 중 가장 작은 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 시간 복잡도O(n^2)

### 셀렉션 알고리즘
- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
- 최솟값, 최대값 혹은 중간값을 찾는 알고리즘
- k가 비교적 작을 때 유용하며 O(kn)의 수행시간을 필요로 한다.

### 추가로 알게된 것
- board = [[0] * N for _ in range(N)] ,없이 프린트하는법
   ```
   board = [[0] * N for _ in range(N)]
   for r in board:
      print(*r)
      print(*r, sep='') #띄어쓰기 없게 출력
      print(''.join(map(str, r)), sep=' ')
   ```
- 어디에 단어가 들어갈 수 있을까(swea_1979), 사다리타기(swea_1210)과 같이 옆으로 계속 이동해야 하는 경우 while문을 사용하면 한쪽으로 계속 이동할 수 있다.
- 세가지 배열 나란히 출력하기
   ```
       for a in range(N):
        print(*arr_90[a], sep='', end=' ')
        print(*arr_180[a], sep='', end=' ')
        print(*arr_270[a], sep='', end=' ')

         # 741 987 369 
         # 852 654 258 
         # 963 321 147 
   ```
# 20240202
## 추가로 알게된 것
- result = ' '.join(map(str, boxes))를 할 경우 띄어쓰기까지 하나의 인덱스로 들어간다 
- 받아오는 리스트에 요소를 추가하고 싶을땐 list = [list(map(int, input().split())) + [0] for _ in range(N)] +[[0] * (N+1)] -> 리스트의 아래, 오른쪽에 0요소 추가 
# 20240205
## 문자의 표현
## ASCII
- 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.
- list(input)과  input()의 차이
  ```
  s1 = list(input) -> ['a', 'b', 'c']
  s2 = input()
  ``` ->'abc'
- 자기 분자열을 이용할 경우 swap을 위한 임시변수가 필요하며 반복 순행을 문자열 길이의 반만을 수행해야 한다
- ord: 아스키 코드를 알려줌
### 추가로 알게된 것
- for문을 많이 겹치는 것보다 안 겹치고 쌓아서 하는게 훨씬 빠르다
- arr = reversed(문자열)을 넣으면 문자열이 아닌 코드 값으로 나온다
# 20240206
### 추가로 알게된 것
- for ~ else : break 없이 for를 다 돌았으면 else를 실행
- count 함수를 쓰면 겹쳐져 있는 문자의 개수를 포함한다
   ```
   A = 'aaa'
   B = 'aa'
   A.count(B) == 2
   ```
- 배열을 재배열하는 것보다 자료구조를 활용하는 것이 훨씬 빠르다
   ```
   #1
   arr = arr[:-2]
   #2
   for _ in range(2):
      arr.pop()
   # 2번이 훨씬 빠르다
   ```
# 20240207
## Stack
- 선형구조 : 자료간의 관계가 1대 1의 관계를 갖는다
- 후입선출(LIFO) : 마지막에 삽입한 자료를 먼저 꺼낸다
   ### isEmpty()
- 스택이 공백인지 아닌지를 확인하는 연산
   ### peek
  - 스택의 top에 있는 item(원소)를 반환하는 연산
## Menoization(메모이제이션)
- 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠를게 하는 기술, 동적 계획법의 핵심
## 추가로 알게 된 것
- 재귀함수에서 같은 함수를 호출해도 메모리가 구분된다(다른 함수를 호출하는 것과 동일)
# 20240208
## DP
- 동적 계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 입력 크기가 작은 부분 문제들을 모두 해결한 후 그 해들을 이용하여 보다 큰 크기의 부분 문제를 해결
- 구현 방식
   1. recursive 방식 : fib1()
   2. iterative 방식
## 비선형구조 그래프 구조 검색
   1. 깊이 우선 탐색(DPS)
   2. 너비 우선 탐색(BFS)
# 20240213
## Stack 활용
1. 문자열 수식 계산
   - 후위 표기법
     - 연산자를 피연산자의 뒤에 표기하는 방법(AB+)
   - 중위 표기법
     - 연산자를 피연산자의 가운데 표기하는 방법(A+B)
   - 전위 표기법
     - 연산자를 피연산자 앞에 표기하는 방법(+AB)
2. 백트래킹
- 해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아가는 기법
- 최적화(Optimization) 문제와 결정(Decision) 문제를 해결할 수 있다
- 결정문제
  - 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes 또는 no로 답하는 문제
    - 미로찾기
    - n-Queen 문제
    - Map coloring
    - 부분 집합의 합 문제
- 백트래킹과 깊이우선탐색과의 차이
  - 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
  - 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가능
  - 백트래킹 알고리즘 절차
    1. 상태 공간 트리의 깊이 우선 검색을 실시
    2. 각 노드가 유망한지 점검
    3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속함  
# 20240214
### 추가로 알게된 것
- 모든 경우를 구해야 하는 경우에는 비트연산자가 빠르지만 합과 같이 가지치기가 가능한 상황에선 백트래킹을 이용하는 것이 빠르다
# 20240215
## 큐(Queue)
- 잘못된 포화상태 인식
  - 선형 큐를 이용하여 삽입과 삭제를 계속할 경우 배열의 앞부분에 활용할 수 있는 공간이 있음에도 rear = n-1 즉 포화 상태로 인식
## 원형 큐
## 연결 큐
## deque(덱)
- 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너
## 우선순위 큐
- 우선순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다
## 버퍼
- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리 영역
- 버퍼링 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미
# 20240216
## BFS(너비 우선 탐색)
- 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식(큐를 활용)
### 추가로 알게 된 것
```
# 리스트에서 2개씩 받기
V, E = map(int, input().split())
arr = list(map(int, input().split()))
adjl = [[] for _ in range(V+1)]
for i in range(E):
   n1, n2 = arr[i*2], arr[i*2+1]
   adjl[n2].append(n1)
   adjl[n1].append(n2)
```
# 20240220
## 트리
- 노드 = 트리의 원소
- 간선 = 노드를 연결하는 선(부모와 자식 노드를 연결)
- 루트노드 = 트리의 시작 노드
- 형제노드 - 같은 부모 노드의 자식 노드들
- 조상 노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브 트리 - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 - 서브 트리에 있는 하위 레벨의 노드들
- 노드의 차수: 노드에 연결된 자식 노드의 수
- 단말노드: 차수가 0인 노드
### 이진 트리
-  모든 노드들이 2개의 서브트리를 갖느 특별한 형태의 트리
-  **각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리**
-  레벨 i에서의 노드의 최대 개수는 2^i 개
-  높이가 h인 이진트리가 가질 수 있는 노드의 최소 개수는 h+1개, 최대는 2^(h+1) -1
### 포화 이진 트리
- 모든 레벨의 노드가 포화상태로 차 있는 이진트리
- 루트를 1번으로 하여 정해진 위치에 대한 노드 번호를 가짐
### 완전 이진 트리
- 포화 이진 트리의 노드 번호 1번부터 n번까지 빈자리가 없는 이진트리
### 편향 이진 트리
- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
### 순회
- 노드들을 체계적으로 방문한는 것
- 순회방법
  - 전위 순회 : 부모노드 방문 후 자식노드를 좌,우 순서로 방문
  - 중위 순회 : 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문
  - 후위 순회 : 자식노드를 좌우 순서로 방문 후 부모노드로 방문
# 20240221
## 이진 탐색 트리
- 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다 : O(h), 평균의 경우 이진 트리가 균형적으로 생성되어 있는 경우 O(log n), 최악의 경우 : O(n)
## 힙 조건
1. 완전 이진트리
```
# 최대 힙
def enq(n):
   global last
   last += 1
   h[last] = n
   c = last 
   while q>=1 and h[p]<va>
```
# 20240222
### 빅오 표기법
- N번 반복 -> O(N)
- f(n) = 2n^2+7n+4 = O(n^2) -> 상수 배제
- for i in range(50) -> O(1)
- O(5N) -> 5배수 강조해서 표현하고 싶을 때(알고리즘 성능을 미세하게 비교)
- N = 10000 이고 O(log N) -> 14 (알고리즘에서 밑수는 10이 아닌 2이다) 
- O(logN)은 O(1)보다 느리지만 유사한 성능을 보인다
- O(NlogN)은 O(N)보다 느리지만 유사한 성능을 보인다
### 진수
- 2진수를 10진수를 변환 시 연산이 오래 걸림
- 2진수를 16진수로 변환 시 연산 속도가 매우 빠름
### 비트 연산
- 1bit : 0과 1을 표현하는 정보의 단위
- 1Byte: 8bit를 묶어 1Byte
- 임의의 수로 2회 XOR을 하면 원래 수로 돌아온다
- 음수표현 방법
  - 컴퓨터는 음수를 2의 보수로 관리
  - 맨 앞자리 bit(MSB)는 음수 or 양수를 구분하는 비트 (1 ->음수, 0 -> 양수)
  - 양수의 2진수를 뒤집고 + 1
- Not 연산자 : 모든 연산자를 반전시킨다\
  - 파인썬에서는 ~4를 수행하면 -5가 출력된다
### 실수
- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다
- 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이떄 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다( ex) print(0.1+0.1+0.1) == 0.3 --> False )
# 반복과 재귀
- 재귀를 연습하기 전 알아야 할 함수의 특징
  1. int 타입 객체를 전달하면 값만 복사된다
  2. 함수가 끝나면 main이 아닌 해당 함수를 호출했던 곳으로 돌아온다
- 재귀호출의 시작은 무한 재귀호출을 막는 것 부터 시작한다(기저조건)
## 순열
- 서로 다른 N개에서 R개를 중복없이 순서를 고려하여 나열하는 것
### 중복순열 구현 원리
1. 재귀 호출을 할 때 마다, 이동 경로를 흔적으로 남긴다
2. 가장 마지막 레벨에 도착했을 때 이동 경로를 출력한다
### 중복을 취급하지 않는 순열 구현 방법
1. 중복순열 코드를 작성한다
2. 중복을 제거하는 코드를 추가한다
- 중복을 제거하는 원리
  - 전역 리스트를 사용하면 이미 선택했던 숫자인지 구분할 수 있다
# 20240228
## 부분집합, 조합 / 그리디
### 부분집합
- 집합에 포함된 원소들을 선택하는 것(아무것도 선택하지 않은 것도 포함)
- 구현방법
  1. 완전탐색
  2. Binary Counting  
### 조합
- 서로 다른 n개의 원소 중 r개를 순서없이 골라낸 것
- 순열과 조합의 차이
  - 순열: ABC 와 CAB는 다르다
  - 조합: ABC 와 CAB는 같다
### 그리디
- 결정이 필요할 때 현재 기준으로 가장 좋아 보이는 선택지로 결정하여 답을 도출하는 알고리즘
 # WEB
 # 20240306
 ## HTML
 - 웹 페이지의 의미와 구조를 정의하는 언어
 - h1요소는 단순히 텍스트를 크게 만드는 것이 아닌 현재 문서의 최상위 제목이라는 의미를 부여하는 것
 - 태그 안에서 엔터는 불가능 br 태그로 줄바꿈 가능
 - 검색을 할때 mdn 문서를 최우선적으로 참고
## CSS
- 웹 페이지의 디자인과 레이아웃을 구성하는 언어
- 선언을 끝낼 때 ;이 필요 
- 한 요소에 동일한 가중치를 가진 선택자가 적용될 때 CSS에서 마지막에 나오는 선언이 적용됨
- 속성은 되도록 'class'만 사용할 것
  - 여러 선택자들과 함께 사용할 경우 우선순위 규칙에 따라 예기치 못한 스타일 규칙이 적용되어 전반적인 유지보수가 어려워지기 때문
# 20240307
## CSS
- box의 width는 박스안의 컨텐츠 너비를 의미 -> box-sizing: border-box로 바꿔주어야 함
- box의 너비를 볼 때 테두리의 길이도 고려해야함
### Inline, Block
- 인라인 요소를 가운데 정열할떄는 text-align: center 사용, block 요소를 가운데 정렬할 때는 margin left, right: auto 사용 
### Position 유형
-  전체 페이지에 대한 레이아웃을 구성하는 것이 아닌 페이지 특정 항목의 위치를 조정
   1. static
   2. relative: 본인의 static 위치를 기준으로 이동
      - 이동하더라도 본인의 static 위치를 잊지 않는다
   3. absolute : 본인의 공간을 가지지 않는다
      - 공중에 떠 있다고 생각하면 편하다
      - 부모 영역을 기준으로 이동 - > 부모에게 position: relative를 주어야 함
   4. fixed
      - absolute와 마찬가지로 집을 나가지만 움직이지 않는다(차지하는 공간x)
   5. sticky
      - 특정한 임계점이 오기전까진 noraml flow, 특정한 위치가 되는 순간 fixed로 바뀜
      - 동일한 임계점에 도착한 다음 sticky가 있다면 다음 sticky를 위에 올려준다
### CSS Flexbox
- 요소를 행과 열 형태로 배치하는 1차원 레이아웃 방식
- main axis(주 축)
  - flex item들이 배치되는 기본 축 
- cross axis(교차 축)
  - main axis 에 수직인 축
- align-items : 한줄 정렬 -> 두 줄이 되는순간 정렬이 풀린다(items가 아닌 content로 해야함)
# 20240308
## Bootstrap
- 미리 만들어진 다양한 디자인 요소들을 제공하여 웹 사이트를 빠르고 쉽게 개발할 수 있도록 함
- 영어 사이트에 들어갈 것(한글은 누락된 부분이 있음)
- 로컬에서 CSS를 가져오는게 아닌 온라인 상에서 가져옴
- rem: 루트 픽셀을 기준으로 상대적인 크기를 정함
- 단점: 개발자의 자유도가 제한된다
### CDN
- 지리적 제약없이 빠르고 안전하게 콘텐츠를 전송할 수 있는 전송 기술
### 케로젤
- 케로젤의 id와 각 버튼의 data-bs-target이 일치하는지 봐야 함
### 모달
- 모달 id값과 버튼의 data-bs-target이 일치하는지 봐야 함
- 주의 사항
   1. 모달 코드와 버튼 코드가 반드시 함께 다녀야 할까? -> X (모달 코드는 보통 맨 아래쪽에 모아둠)
   2. 모달 코드가 다른 코드 안쪽에 중첩되어 들어가버리면 모달이 켜졌을때 회색화면 뒤쪽에 감춰질 수 있다
   3. 모달 코드는 주로 바디 태그가 닫히는 곳에 모아두는 것을 권장한다 
### 시맨틱 웹
- 웹 데이터를 의미론적으로 구조화된 형태로 표현하는 방식
# 20240311
## WEB
### 단축 코드
- emmet cheat sheet
### 단축키
- ctrl + l : 한 줄 선택
- ctrl + d : 동일한 키워드 연속 선택
- ctrl + alt + 화살표 : 멀티 커서
- alt + 클릭 : 멀티 커서
- alt + 화살표 : 선택한 라인 끌고 가기
- alt + shift + 화살표 : 선택한 라인 복사
### 부트스트랩 그리드 시스템
- 웹 페이지의 레이아웃을 조정하는 데 상요된느 12개의 컬럼으로 구성된 프로그램
- 하나의 웹페이지를 다양한 기기에서 적절하게 표현
- 12개로 구성된 이유: 약수가 많다 -> 레이아웃을 많들 수 있는 경우가 많아진다.
- 거터 값은 행이 컨트롤
- 거터를 좌우로 줄 때는 패딩이기 때문에 컨텐츠의 크기에 영향을 준다
-  그리드 카드: 카드에만 적용되는 그리드 시스템
   - 칸 수가 아닌 카드 수가 기준
   - 컬럼이 아닌 로우 하나에서 컨트롤
   - 오프셋은 필요한 애한테 따로 적어줌
# 20240312
## Django
- 파이썬 기반의 대표적인 웹 프레임워크
- 다른 이름이 가상환경을 만들 수 있더라도 만들지 않는다 (venv)
- python -m venv venv: 마지막은 가상환경 이름
- 의존성
### 디자인 패턴
소프트웨어 설계에서 발생하는 문제를 해결하기 위한 일반적인 해결책
- MVC 디자인 패턴: 애플리케이션ㅇ르 구조화하는 대표적인 패턴
- MTV 디자인 패턴: Django에서 애플리케이션을 구조화하는 패턴(이름만 다름)
## 추가로 알게된 점
- 프로젝트 파일과 manage.py, 앱은 일직선상에 있어야 한다
# 20240313
## Django
### DTL
- template에서 조건, 반복, 변수 등의 프로그래밍적 기능을 제공하는 시스템
# 20240314
## Django
### URL 이름 공간
- app_name은 맞춰 주어야 함